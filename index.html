<!DOCTYPE html>
<html lang="sv">
<head>
  <meta charset="UTF-8">
  <title>X eller Y – med datum och veckodag</title>
  <style>
    body { 
      display: flex; 
      flex-direction: column;
      justify-content: center; 
      align-items: center; 
      height: 100vh; 
      font-family: Arial, sans-serif; 
      transition: background 1.5s ease;
      background: linear-gradient(135deg, #0BA2F4, #004080);
    }
    .letter { 
      font-size: 15rem;
      font-weight: bold; 
      display: inline-block;
      transition: transform 0.6s ease, opacity 0.6s ease;
      transform-origin: center;
      opacity: 1;
      visibility: hidden; /* Fix mot “hoppet” */
    }
    .date, .weekday {
      font-size: 4rem;
      font-weight: bold;
      margin-top: 0.5rem;
      opacity: 1;
      visibility: hidden; /* Fix mot “hoppet” */
      transition: transform 0.6s ease, opacity 0.6s ease;
    }
    .next-workday-text,
    .clock-text,
    .countdown-text {
      font-size: 2rem;
      font-weight: bold;
      text-align: center;
      margin-top: 0.5rem;
      overflow-wrap: break-word;
      word-wrap: break-word;
      max-width: 90vw;
      opacity: 1;
      visibility: hidden; /* Fix mot “hoppet” */
      transition: transform 0.6s ease, opacity 0.6s ease;
    }
    .letter, .date, .weekday, .next-workday-text, .clock-text, .countdown-text {
      color: #fff;
      text-shadow: 2px 2px 6px rgba(0,0,0,0.5);
    }
  </style>
</head>
<body>
  <div class="letter" id="letter"></div>
  <div class="date" id="date"></div>
  <div class="weekday" id="weekday"></div>
  <div class="clock-text" id="clock-text"></div>
  <div class="next-workday-text" id="next-workday-text"></div>
  <div class="countdown-text" id="countdown-text"></div>

  <script>
    const startDate = new Date("2025-01-02");
    let holidays = [];

    const localHolidays = [
      "2025-01-01","2025-01-06","2025-04-18","2025-04-20","2025-04-21","2025-05-01","2025-05-29","2025-06-06","2025-06-20","2025-06-21","2025-11-01","2025-12-24","2025-12-25","2025-12-26",
      "2026-01-01","2026-01-06","2026-04-03","2026-04-05","2026-04-06","2026-05-01","2026-05-14","2026-05-24","2026-06-06","2026-06-20","2026-10-31","2026-11-01","2026-12-24","2026-12-25","2026-12-26",
      "2027-01-01","2027-01-06","2027-04-02","2027-04-04","2027-04-05","2027-05-01","2027-05-13","2027-05-23","2027-06-06","2027-06-26","2027-10-31","2027-11-01","2027-12-24","2027-12-25","2027-12-26",
      "2028-01-01","2028-01-06","2028-04-14","2028-04-16","2028-04-17","2028-05-01","2028-05-25","2028-06-04","2028-06-06","2028-06-23","2028-06-24","2028-10-31","2028-12-24","2028-12-25","2028-12-26",
      "2029-01-01","2029-01-06","2029-03-30","2029-04-01","2029-04-02","2029-05-01","2029-05-10","2029-05-20","2029-06-06","2029-06-22","2029-06-23","2029-11-03","2029-12-24","2029-12-25","2029-12-26"
    ];

    async function fetchHolidays(year) {
      try {
        const res = await fetch(`https://api.dagsmart.se/holidays?year=${year}&weekends=false`);
        if (!res.ok) throw new Error("Fel vid hämtning av helgdagar från API");
        const data = await res.json();
        return data.map(h => h.date);
      } catch (err) {
        console.warn("API saknas, fallback till lokal lista:", err);
        return localHolidays.filter(d => d.startsWith(String(year)));
      }
    }

    async function getSwedishTime() {
      try {
        const res = await fetch("https://worldtimeapi.org/api/timezone/Europe/Stockholm");
        if (!res.ok) throw new Error("Fel vid hämtning av tid från API");
        const data = await res.json();
        return new Date(data.datetime);
      } catch (err) {
        console.warn("Kunde inte hämta svensk tid, fallback till lokal tid:", err);
        return new Date();
      }
    }

    async function loadHolidays() {
      const thisYear = new Date().getFullYear();
      const nextYear = thisYear + 1;
      const [h1, h2] = await Promise.all([fetchHolidays(thisYear), fetchHolidays(nextYear)]);
      holidays = [...h1, ...h2];
    }

    async function refreshHolidaysFromAPI() {
      const thisYear = new Date().getFullYear();
      const nextYear = thisYear + 1;
      try {
        const [h1, h2] = await Promise.all([fetchHolidays(thisYear), fetchHolidays(nextYear)]);
        holidays = [...h1, ...h2];
        console.log("Hämtade helgdagar från API igen!");
      } catch (err) {
        console.warn("API fortfarande nere, fortsätter med lokal lista:", err);
      }
    }
    setInterval(refreshHolidaysFromAPI, 6 * 60 * 60 * 1000);

    function isValidWorkday(date) {
      const day = date.getDay();
      const str = date.toISOString().split("T")[0];
      if (day === 0 || day === 6) return false;
      if (holidays.includes(str)) return false;
      if (date.getMonth() === 11 && date.getDate() === 24) return false;
      if (date.getMonth() === 11 && date.getDate() === 31) return false;
      if (date.getMonth() === 5 && day === 5 && date.getDate() >= 19 && date.getDate() <= 25) return false;
      return true;
    }

    function countWorkdays(from, to) {
      let count = 0;
      const cur = new Date(from);
      while (cur <= to) {
        if (isValidWorkday(cur)) count++;
        cur.setDate(cur.getDate() + 1);
      }
      return count;
    }

    function capitalize(str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
    }

    let currentLetter = null;

    async function displayLetter(doFlip = true) {
      let now = await getSwedishTime();

      let workdayCheck = new Date(now);
      if (workdayCheck.getHours() < 5 || (workdayCheck.getHours() === 5 && workdayCheck.getMinutes() < 30)) {
        workdayCheck.setDate(workdayCheck.getDate() - 1);
      }

      let today = new Date(now);
      today.setHours(0,0,0,0);

      if (holidays.length === 0) await loadHolidays();

      let refDate = new Date(workdayCheck);
      refDate.setHours(0,0,0,0);
      if (!isValidWorkday(refDate)) {
        while (!isValidWorkday(refDate) && refDate >= startDate) {
          refDate.setDate(refDate.getDate() - 1);
        }
      }

      const count = countWorkdays(startDate, refDate);
      const letter = (count % 2 === 0) ? "Y" : "X";

      const letterEl = document.getElementById("letter");

      document.body.style.background = (letter === "X") 
        ? "linear-gradient(135deg, #0BA2F4, #004080)"
        : "linear-gradient(135deg, #27F584, #008040)";

      if (doFlip || letter !== currentLetter) {
        letterEl.style.transform = "rotateY(90deg)";
        letterEl.style.opacity = 0;
        setTimeout(() => {
          letterEl.textContent = letter;
          letterEl.style.transform = "rotateY(0deg)";
          letterEl.style.opacity = 1;
          letterEl.style.visibility = "visible";
          document.querySelectorAll(".date, .weekday, .next-workday-text, .clock-text, .countdown-text")
            .forEach(el => el.style.visibility = "visible");
        }, 600);
      } else {
        letterEl.textContent = letter;
      }

      currentLetter = letter;

      const yyyy = now.getFullYear();
      const mm = String(now.getMonth() + 1).padStart(2, "0");
      const dd = String(now.getDate()).padStart(2, "0");
      document.getElementById("date").textContent = `${yyyy}-${mm}-${dd}`;
      document.getElementById("weekday").textContent = capitalize(now.toLocaleDateString('sv-SE', { weekday: 'long' }));
    }

    function getNextWorkdayStart(now) {
      let next = new Date(now);
      next.setHours(5,30,0,0);
      if (now >= next) next.setDate(next.getDate() + 1);
      while (!isValidWorkday(next)) next.setDate(next.getDate() + 1);
      return next;
    }

    async function updateClockAndCountdown() {
      const now = await getSwedishTime();

      let nextWorkday = new Date(now);
      nextWorkday.setHours(5,30,0,0);
      if (now >= nextWorkday) nextWorkday.setDate(nextWorkday.getDate() + 1);
      while (!isValidWorkday(nextWorkday)) {
        nextWorkday.setDate(nextWorkday.getDate() + 1);
        nextWorkday.setHours(5,30,0,0);
      }

      const yyyy = nextWorkday.getFullYear();
      const mm = String(nextWorkday.getMonth() + 1).padStart(2,"0");
      const dd = String(nextWorkday.getDate()).padStart(2,"0");
      const weekday = nextWorkday.toLocaleDateString("sv-SE", { weekday: "long" });
      document.getElementById("next-workday-text").textContent = `Nästa arbetsdygn börjar ${weekday} ${yyyy}-${mm}-${dd} 05:30`;

      const nowHours = String(now.getHours()).padStart(2,'0');
      const nowMinutes = String(now.getMinutes()).padStart(2,'0');
      const nowSeconds = String(now.getSeconds()).padStart(2,'0');
      document.getElementById("clock-text").textContent = `Klockan är nu ${nowHours}:${nowMinutes}:${nowSeconds}`;

      const diff = nextWorkday - now;
      const hoursLeft = String(Math.floor(diff / (1000*60*60))).padStart(2,'0');
      const minutesLeft = String(Math.floor((diff / (1000*60)) % 60)).padStart(2,'0');
      const secondsLeft = String(Math.floor((diff / 1000) % 60)).padStart(2,'0');
      document.getElementById("countdown-text").textContent = `Tid kvar till nästa arbetsdygn ${hoursLeft}:${minutesLeft}:${secondsLeft}`;
    }

    function scheduleLetterUpdate() {
      getSwedishTime().then(now => {
        const next = getNextWorkdayStart(now);
        const msUntilNext = next - now;
        setTimeout(() => {
          displayLetter(true);
          scheduleLetterUpdate();
        }, msUntilNext);
      });
    }

    setInterval(() => displayLetter(false), 60000);
    displayLetter(true);
    scheduleLetterUpdate();
    setInterval(updateClockAndCountdown, 1000);
  </script>
</body>
</html>
